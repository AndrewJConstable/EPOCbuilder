/*******************************************************************************
 * EPOCBuilderUI.java
 * =============================================================================
 * Copyright (c) 2009-2010 Australian Antarctic Division. All rights reserved.
 * Author can be contacted at troy.robertson@aad.gov.au.
 *
 * Every effort has been taken in making sure that the source code is
 * technically accurate, but I disclaim any and all responsibility for any loss,
 * damage or destruction of data or any other property which may arise from
 * relying on it. I will in no case be liable for any monetary damages arising
 * from such loss, damage or destruction.
 *
 * As with any code, ensure this code is tested in a development environment
 * before attempting to run it in production.
 * =============================================================================
 */
package au.gov.aad.erm.EPOC_Builder;

import au.gov.aad.erm.RJEditor.*;
import static au.gov.aad.erm.EPOC_Builder.Constants.*;

import java.awt.*;
import javax.swing.*;
import javax.swing.tree.*;
import javax.swing.event.*;
import javax.swing.filechooser.FileSystemView;
import java.io.*;
import java.util.*;
import java.awt.event.*;
import java.awt.GridLayout;
import java.awt.Cursor;

/*******************************************************************************
 * Main GUI class for EPOC Builder.  Contains main method.
 * Manages R object creation and revision for EPOC modelling system.
 * Stores all object data using Derby database.
 *
 * @author Troy Robertson
 * @company Australian Antarctic Division
 * @created 10/09/2009
 * @version 0.4.0, 01-09-2010
 *******************************************************************************/
public class EPOCBuilderUI extends javax.swing.JFrame implements TreeSelectionListener {

    private Universe universe;
    private Universe storedUni;     // Unmodified copy of universe as loaded

    private TreePath currentTreePath;
    private DefaultMutableTreeNode currentTreeNode;
    private EPOCObject editObject = null;
    private EPOCObject clipboardObject = null;
    private String lastPath = "";
    private Storage storage = DerbyStorage.getInstance();
    //private JRIExchanger rex = JRIExchanger.getInstance();
    
    /** Creates new form EPOCBuilderUI */
    public EPOCBuilderUI() {
        // Make sure database connection was instantiated properly
        String probs = Messages.getUnreadErrMsgs();
        if (!probs.equals("")) {
            JOptionPane.showMessageDialog(this, probs);
            System.exit(1);
        }

        initComponents();
        loadSettings();
        this.setSize(EPOC_FRAME_SIZE);
        
        universe = storage.getLastVisited();
        //storedUni = universe.clone(EPOC_CLN, true);
        storedUni = storage.getLastVisited();

        jTreeUniverse.setCellRenderer(new UniverseTreeCellRenderer());
        ToolTipManager.sharedInstance().registerComponent(jTreeUniverse);

        loadForm(true);
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jSplitPane1 = new javax.swing.JSplitPane();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTreeUniverse = new javax.swing.JTree();
        jLabelProgress = new javax.swing.JLabel();
        jMenuBar = new javax.swing.JMenuBar();
        jMenuFile = new javax.swing.JMenu();
        jMenuItemNewUni = new javax.swing.JMenuItem();
        jMenuItemOpenUni = new javax.swing.JMenuItem();
        jMenuItemSaveUni = new javax.swing.JMenuItem();
        jMenuItemSaveAsUni = new javax.swing.JMenuItem();
        jMenuItemDeleteUni = new javax.swing.JMenuItem();
        jSeparatorDB = new javax.swing.JSeparator();
        jMenuDB = new javax.swing.JMenu();
        jMenuItemNewDB = new javax.swing.JMenuItem();
        jMenuItemOpenDB = new javax.swing.JMenuItem();
        jMenuItemDeleteDB = new javax.swing.JMenuItem();
        jMenuItemExportDB = new javax.swing.JMenuItem();
        jMenuItemImportDB = new javax.swing.JMenuItem();
        jSeparatorExit = new javax.swing.JSeparator();
        jMenuItemExit = new javax.swing.JMenuItem();
        jMenuView = new javax.swing.JMenu();
        jMenuItemRefresh = new javax.swing.JMenuItem();
        jMenuItemOptions = new javax.swing.JMenuItem();
        jMenuGenerate = new javax.swing.JMenu();
        jMenuItemGenerateR = new javax.swing.JMenuItem();
        jMenuItemGenerateCalendar = new javax.swing.JMenuItem();
        jMenuItemTimeline = new javax.swing.JMenuItem();
        jMenuTools = new javax.swing.JMenu();
        jMenuItemRun = new javax.swing.JMenuItem();
        jMenuItemTextEditor = new javax.swing.JMenuItem();
        jMenuItemValidate = new javax.swing.JMenuItem();
        jMenuItemRepair = new javax.swing.JMenuItem();
        jMenuItemRationalise = new javax.swing.JMenuItem();
        jMenuItemOrphans = new javax.swing.JMenuItem();
        jSeparator1 = new javax.swing.JSeparator();
        jMenuItemImportXML = new javax.swing.JMenuItem();
        jMenuHelp = new javax.swing.JMenu();
        jMenuItemAbout = new javax.swing.JMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.DO_NOTHING_ON_CLOSE);
        setTitle("EPOC Builder - Universe");
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                formWindowClosing(evt);
            }
        });

        jSplitPane1.setDividerLocation(250);
        jSplitPane1.setDividerSize(3);
        jSplitPane1.setResizeWeight(0.3);

        jTreeUniverse.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                jTreeUniverseKeyReleased(evt);
            }
        });
        jScrollPane1.setViewportView(jTreeUniverse);

        jSplitPane1.setLeftComponent(jScrollPane1);

        jLabelProgress.setVerticalAlignment(javax.swing.SwingConstants.BOTTOM);
        jLabelProgress.setMaximumSize(new java.awt.Dimension(2147483647, 2147483647));
        jLabelProgress.setMinimumSize(new java.awt.Dimension(50, 14));
        jLabelProgress.setPreferredSize(new java.awt.Dimension(50, 14));

        jMenuFile.setText("File");
        jMenuFile.setActionCommand("Universe");

        jMenuItemNewUni.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_N, java.awt.event.InputEvent.CTRL_MASK));
        jMenuItemNewUni.setText("New");
        jMenuItemNewUni.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemNewUniActionPerformed(evt);
            }
        });
        jMenuFile.add(jMenuItemNewUni);

        jMenuItemOpenUni.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_O, java.awt.event.InputEvent.CTRL_MASK));
        jMenuItemOpenUni.setText("Open");
        jMenuItemOpenUni.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemOpenUniActionPerformed(evt);
            }
        });
        jMenuFile.add(jMenuItemOpenUni);

        jMenuItemSaveUni.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.event.InputEvent.CTRL_MASK));
        jMenuItemSaveUni.setText("Save");
        jMenuItemSaveUni.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemSaveUniActionPerformed(evt);
            }
        });
        jMenuFile.add(jMenuItemSaveUni);

        jMenuItemSaveAsUni.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_A, java.awt.event.InputEvent.CTRL_MASK));
        jMenuItemSaveAsUni.setText("Save As");
        jMenuItemSaveAsUni.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemSaveAsUniActionPerformed(evt);
            }
        });
        jMenuFile.add(jMenuItemSaveAsUni);

        jMenuItemDeleteUni.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_DELETE, java.awt.event.InputEvent.CTRL_MASK));
        jMenuItemDeleteUni.setText("Delete");
        jMenuItemDeleteUni.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemDeleteUniActionPerformed(evt);
            }
        });
        jMenuFile.add(jMenuItemDeleteUni);
        jMenuFile.add(jSeparatorDB);

        jMenuDB.setText("Database");

        jMenuItemNewDB.setText("New");
        jMenuItemNewDB.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemNewDBActionPerformed(evt);
            }
        });
        jMenuDB.add(jMenuItemNewDB);

        jMenuItemOpenDB.setText("Open");
        jMenuItemOpenDB.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemOpenDBActionPerformed(evt);
            }
        });
        jMenuDB.add(jMenuItemOpenDB);

        jMenuItemDeleteDB.setText("Delete");
        jMenuItemDeleteDB.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemDeleteDBActionPerformed(evt);
            }
        });
        jMenuDB.add(jMenuItemDeleteDB);

        jMenuItemExportDB.setText("Export");
        jMenuItemExportDB.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemExportDBActionPerformed(evt);
            }
        });
        jMenuDB.add(jMenuItemExportDB);

        jMenuItemImportDB.setText("Import");
        jMenuItemImportDB.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemImportDBActionPerformed(evt);
            }
        });
        jMenuDB.add(jMenuItemImportDB);

        jMenuFile.add(jMenuDB);
        jMenuFile.add(jSeparatorExit);

        jMenuItemExit.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_Q, java.awt.event.InputEvent.CTRL_MASK));
        jMenuItemExit.setText("Exit");
        jMenuItemExit.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemExitActionPerformed(evt);
            }
        });
        jMenuFile.add(jMenuItemExit);

        jMenuBar.add(jMenuFile);

        jMenuView.setText("View");

        jMenuItemRefresh.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_ENTER, java.awt.event.InputEvent.ALT_MASK));
        jMenuItemRefresh.setText("Refresh");
        jMenuItemRefresh.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemRefreshActionPerformed(evt);
            }
        });
        jMenuView.add(jMenuItemRefresh);

        jMenuItemOptions.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_O, java.awt.event.InputEvent.ALT_MASK));
        jMenuItemOptions.setText("Options");
        jMenuItemOptions.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemOptionsActionPerformed(evt);
            }
        });
        jMenuView.add(jMenuItemOptions);

        jMenuBar.add(jMenuView);

        jMenuGenerate.setText("Generate");

        jMenuItemGenerateR.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_G, java.awt.event.InputEvent.ALT_MASK));
        jMenuItemGenerateR.setText("R Code");
        jMenuItemGenerateR.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemGenerateRActionPerformed(evt);
            }
        });
        jMenuGenerate.add(jMenuItemGenerateR);

        jMenuItemGenerateCalendar.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_C, java.awt.event.InputEvent.ALT_MASK));
        jMenuItemGenerateCalendar.setText("Calendar");
        jMenuItemGenerateCalendar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemGenerateCalendarActionPerformed(evt);
            }
        });
        jMenuGenerate.add(jMenuItemGenerateCalendar);

        jMenuItemTimeline.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_T, java.awt.event.InputEvent.ALT_MASK));
        jMenuItemTimeline.setText("Timeline");
        jMenuItemTimeline.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemTimelineActionPerformed(evt);
            }
        });
        jMenuGenerate.add(jMenuItemTimeline);

        jMenuBar.add(jMenuGenerate);

        jMenuTools.setText("Tools");

        jMenuItemRun.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_R, java.awt.event.InputEvent.ALT_MASK));
        jMenuItemRun.setText("Run EPOC");
        jMenuItemRun.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemRunActionPerformed(evt);
            }
        });
        jMenuTools.add(jMenuItemRun);

        jMenuItemTextEditor.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_E, java.awt.event.InputEvent.ALT_MASK));
        jMenuItemTextEditor.setText("Text Editor");
        jMenuItemTextEditor.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemTextEditorActionPerformed(evt);
            }
        });
        jMenuTools.add(jMenuItemTextEditor);

        jMenuItemValidate.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_V, java.awt.event.InputEvent.ALT_MASK));
        jMenuItemValidate.setText("Validate");
        jMenuItemValidate.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemValidateActionPerformed(evt);
            }
        });
        jMenuTools.add(jMenuItemValidate);

        jMenuItemRepair.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_L, java.awt.event.InputEvent.ALT_MASK));
        jMenuItemRepair.setText("Repair Broken Links");
        jMenuItemRepair.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemRepairActionPerformed(evt);
            }
        });
        jMenuTools.add(jMenuItemRepair);

        jMenuItemRationalise.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_BACK_SPACE, java.awt.event.InputEvent.ALT_MASK));
        jMenuItemRationalise.setText("Rationalise Templates");
        jMenuItemRationalise.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemRationaliseActionPerformed(evt);
            }
        });
        jMenuTools.add(jMenuItemRationalise);

        jMenuItemOrphans.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_F, java.awt.event.InputEvent.ALT_MASK));
        jMenuItemOrphans.setText("Find Orphaned Objects");
        jMenuItemOrphans.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemOrphansActionPerformed(evt);
            }
        });
        jMenuTools.add(jMenuItemOrphans);
        jMenuTools.add(jSeparator1);

        jMenuItemImportXML.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_I, java.awt.event.InputEvent.ALT_MASK));
        jMenuItemImportXML.setText("Import Template");
        jMenuItemImportXML.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemImportXMLActionPerformed(evt);
            }
        });
        jMenuTools.add(jMenuItemImportXML);

        jMenuBar.add(jMenuTools);

        jMenuHelp.setText("Help");

        jMenuItemAbout.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_H, java.awt.event.InputEvent.ALT_MASK));
        jMenuItemAbout.setText("About");
        jMenuItemAbout.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemAboutActionPerformed(evt);
            }
        });
        jMenuHelp.add(jMenuItemAbout);

        jMenuBar.add(jMenuHelp);

        setJMenuBar(jMenuBar);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jSplitPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 864, Short.MAX_VALUE)
            .addComponent(jLabelProgress, javax.swing.GroupLayout.DEFAULT_SIZE, 864, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jSplitPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 552, Short.MAX_VALUE)
                .addGap(0, 0, 0)
                .addComponent(jLabelProgress, javax.swing.GroupLayout.PREFERRED_SIZE, 15, javax.swing.GroupLayout.PREFERRED_SIZE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void loadSettings() {
        String val="", val2="";
        Dimension fs = new Dimension();
        val = storage.getSetting("version");
        if (!val.equals("")) EPOC_DBVER = val;
        val = storage.getSetting("r_element_str");
        if (!val.equals("")) EPOC_ELESTR = val;
        val = storage.getSetting("debug");
        if (!val.equals("")) EPOC_DBG = Boolean.valueOf(val);
        val = storage.getSetting("allow_templ_edit");
        if (!val.equals("")) EPOC_EDIT_TEMPL = Boolean.valueOf(val);
        val = storage.getSetting("template_linked_objects");
        if (!val.equals("")) EPOC_TMPL_LINK_OBJ = Boolean.valueOf(val);
        val = storage.getSetting("import_linked_objects");
        if (!val.equals("")) EPOC_IMP_LINK_OBJ = Boolean.valueOf(val);
        val = storage.getSetting("match_member_objects");
        if (!val.equals("")) EPOC_AUTO_MATCH_MEMBERS = Boolean.valueOf(val);
        val = storage.getSetting("match_linked_objects");
        if (!val.equals("")) EPOC_AUTO_MATCH_LINK_OBJ = Boolean.valueOf(val);
        val = storage.getSetting("match_linked_templ_objects");
        if (!val.equals("")) EPOC_AUTO_MATCH_LINK_TEMPL_OBJ = Boolean.valueOf(val);
        val = storage.getSetting("list_ordering");
        if (!val.equals("")) EPOC_LIST_ORDERING = Integer.valueOf(val);
        val = storage.getSetting("frame_size_width");
        val2 = storage.getSetting("frame_size_height");
        if (!val.equals("") && !val2.equals("")) fs = new Dimension (Integer.valueOf(val), Integer.valueOf(val2));
        if (fs.getWidth() > 800 && fs.getHeight() > 600) EPOC_FRAME_SIZE = fs;
    }

    private void saveSettings() {
        storage.setSetting("version", EPOC_DBVER, "Current EPOC schema version");
        storage.setSetting("r_element_str", EPOC_ELESTR, "R code dummmy string");
        storage.setSetting("debug", String.valueOf(EPOC_DBG) , "Debug mode");
        storage.setSetting("allow_templ_edit", String.valueOf(EPOC_EDIT_TEMPL) , "Allow edit of templates");
        storage.setSetting("template_linked_objects", String.valueOf(EPOC_TMPL_LINK_OBJ) , "Template linked objects");
        storage.setSetting("import_linked_objects", String.valueOf(EPOC_IMP_LINK_OBJ) , "Import linked objects");
        storage.setSetting("match_member_objects", String.valueOf(EPOC_AUTO_MATCH_MEMBERS) , "Perform object matching on import and save as");
        storage.setSetting("match_linked_objects", String.valueOf(EPOC_AUTO_MATCH_LINK_OBJ) , "Perform automatic broken linked object matching");
        storage.setSetting("match_linked_templ_objects", String.valueOf(EPOC_AUTO_MATCH_LINK_TEMPL_OBJ) , "Perform automatic broken linked object matching to template list");
        storage.setSetting("list_ordering", String.valueOf(EPOC_LIST_ORDERING), "Template list ordering strategy");
        storage.setSetting("frame_size_width", String.valueOf((int)this.getWidth()), "Initial frame width");
        storage.setSetting("frame_size_height", String.valueOf((int)this.getHeight()), "Initial frame height");
        storage.setLastVisited(universe.getUID());
    }

    /**
     * Calls loadForm() and then selects the universe node
     * @param setUniSelected
     */
    private void loadForm(boolean setUniSelected) {
        loadForm();
        if (setUniSelected == true) jTreeUniverse.setSelectionRow(0);
    }

    /**
     * Load the JTree with a tree model of the universe and add a
     * listeners for actions on the tree and mouse right clicks for a popup menu.
     */
    private void loadForm() {
        this.setTitle(universe.getTitle());
        this.setIconImage(new ImageIcon(getClass().getResource("/icons/earth.png")).getImage());

        // build the model
        jTreeUniverse.setModel(buildTreeModel());
        jTreeUniverse.setSelectionModel(new VetoableTreeSelectionModel());
        jTreeUniverse.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
        jTreeUniverse.addTreeSelectionListener(this);

        //Add listener to components that can bring up popup menus.
        MouseListener popupListener = new PopupListener(new JPopupMenu());
        jTreeUniverse.addMouseListener(popupListener);
    }

    private void jMenuItemNewUniActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemNewUniActionPerformed
        if (checkAndSave()) {
            universe = new Universe();

            loadForm(true);
        }
}//GEN-LAST:event_jMenuItemNewUniActionPerformed

    private void jMenuItemSaveUniActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemSaveUniActionPerformed
        if (!saveOpposingForm()) return;

        setProgress("Saving universe to database...");
        if (!universe.saveToStorage() || !universe.saveUnusedTemplateObjects()) {
            endProgress();
            JOptionPane.showMessageDialog(this, Messages.getUnreadErrMsgs(), "Error", JOptionPane.ERROR_MESSAGE);
            return;
        }
        saveSettings();
        storedUni = new Universe(universe.getUID());
        endProgress();

        JOptionPane.showMessageDialog(this, "Universe saved successfully.");
}//GEN-LAST:event_jMenuItemSaveUniActionPerformed

    private void jMenuItemOpenUniActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemOpenUniActionPerformed
        ArrayList uniList;
        String txt;

        if (checkAndSave()) {
            txt = "Select a Universe to open from the following list:";
            // list all universes except this
            uniList = universe.getNegStorageList();

            ListSelectorUI selUI = new ListSelectorUI(txt, uniList);
            final JOptionPane pane = new JOptionPane(selUI, JOptionPane.QUESTION_MESSAGE,
                    JOptionPane.OK_CANCEL_OPTION);
            JDialog dialog = pane.createDialog(this, "Open Universe");
            dialog.setLocationRelativeTo(this);
            dialog.pack();
            dialog.setVisible(true);

            // Make sure a valid response was returned
            Object selVal = pane.getValue();
            if (selVal == null || selVal == JOptionPane.UNINITIALIZED_VALUE) return;
            if(selVal instanceof Integer && ((Integer)selVal).intValue() == JOptionPane.CANCEL_OPTION) return;
            int choice = selUI.getSelectionIndex();
            if (choice < 0) return;

            setProgress("Loading " + ((String[])uniList.get(choice))[1] + "...");
            universe = new Universe(Integer.parseInt(((String[])uniList.get(choice))[0]));
            storedUni = new Universe(universe.getUID());
            loadForm(true);
            endProgress();
        }
}//GEN-LAST:event_jMenuItemOpenUniActionPerformed

    private void jMenuItemSaveAsUniActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemSaveAsUniActionPerformed
        if (!saveOpposingForm()) return;

        String newName = JOptionPane.showInputDialog(this, "Enter new Universe name", "Copy_of_" + universe.getShortName());
        if (newName == null || newName.equals("") || newName.equals(universe.getShortName())) return;

        setProgress("Saving universe as " + newName + "...");
        Universe uni = (Universe)universe.replicate(universe);
        // Rebuild internal structure
        uni.remakeLinks();
        // Try find alternative objects to broken links
        if (EPOC_AUTO_MATCH_LINK_OBJ) uni.repairBrokenLinks();
        uni.setShortName(newName);

        // Save new universe
        if (!uni.saveToStorage() || !uni.saveUnusedTemplateObjects()) {
            endProgress();
            JOptionPane.showMessageDialog(this, Messages.getUnreadErrMsgs(), "Error", JOptionPane.ERROR_MESSAGE);
            return;
        }
        saveSettings();

        // load it into GUI
        universe = uni;
        storedUni = new Universe(universe.getUID());
        loadForm(true);
        endProgress();
}//GEN-LAST:event_jMenuItemSaveAsUniActionPerformed

    private void jMenuItemDeleteUniActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemDeleteUniActionPerformed
        if (!saveOpposingForm()) return;

        Object[] options = {"OK", "Cancel"};
        String txt = "Delete current Universe(" + universe.getShortName() + "." + universe.getRevision() + ")?";
        int choice = JOptionPane.showOptionDialog(this, txt, "Delete",
                JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null,
                options, options[0]);
        //System.out.println(choice);
        if (choice == 0) {
            if (!universe.delete()) {
                JOptionPane.showMessageDialog(this, Messages.getUnreadErrMsgs(), "Error", JOptionPane.ERROR_MESSAGE);
            } else {
                universe = new Universe();

                loadForm(true);
            }
        }
}//GEN-LAST:event_jMenuItemDeleteUniActionPerformed

    private void jMenuItemNewDBActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemNewDBActionPerformed
        String nm = JOptionPane.showInputDialog(this, "Enter new database name.");
        if (nm == null) return;

        if (nm.equals("")) {
            JOptionPane.showMessageDialog(this, "A new database name must be entered!");
            return;
        }

        // list all databases
        ArrayList dbList = storage.getDBAvailableList(true);
        for (int i = 0; i < dbList.size(); i++) {
            if (((String[])dbList.get(i))[1].equals(nm)) {
                if (JOptionPane.showConfirmDialog(this,
                        "Database " + nm + " already exists\n" +
                        "Do you wish to connect to it?",
                        "Database exists",
                        JOptionPane.YES_NO_OPTION) == JOptionPane.NO_OPTION) {
                    return;
                }
            }
        }

        if (checkAndSave()) {
            Storage oldStorage = storage;
            try {
                storage = DerbyStorage.getInstance(nm);
            } catch (Exception e) {
                JOptionPane.showMessageDialog(this, e.getMessage());
                storage = oldStorage;
            }
            universe = storage.getLastVisited();

            loadForm(true);
        }
}//GEN-LAST:event_jMenuItemNewDBActionPerformed

    private void jMenuItemOpenDBActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemOpenDBActionPerformed
        if (checkAndSave()) {
            String txt = "Select a Database connection from the following list:";
            // list all databases except this
            ArrayList dbList = storage.getDBAvailableList(true);

            ListSelectorUI selUI = new ListSelectorUI(txt, dbList);
            final JOptionPane pane = new JOptionPane(selUI, JOptionPane.QUESTION_MESSAGE,
                    JOptionPane.OK_CANCEL_OPTION);
            JDialog dialog = pane.createDialog(this, "Database Connection");

            dialog.setLocationRelativeTo(this);
            dialog.pack();
            dialog.setVisible(true);

            String choice = (String)selUI.getSelectionObject();

            if (choice != null && !choice.equals("")) {
                Storage oldStorage = storage;
                try {
                    storage = DerbyStorage.getInstance(choice);
                } catch (Exception e) {
                    JOptionPane.showMessageDialog(this, e.getMessage());
                    storage = oldStorage;
                }

                universe = storage.getLastVisited();

                loadForm(true);
            }
        }
}//GEN-LAST:event_jMenuItemOpenDBActionPerformed

    private void jMenuItemDeleteDBActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemDeleteDBActionPerformed
        if (!saveOpposingForm()) return;

        if (storage.getDBName().equalsIgnoreCase(DB_NAME)) {
            JOptionPane.showMessageDialog(this, "You cannot delete default EPOC Builder database!");
            return;
        }
        String txt = "Delete current Database(" + storage.getDBName() + ")?";

        Object[] options = {"OK", "Cancel"};
        int choice = JOptionPane.showOptionDialog(this, txt, "Delete",
                JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null,
                options, options[0]);
        if (choice == 0) {
            String delDB = storage.getDBName();
            // first open default DB
            Storage oldStorage = storage;
            try {
                storage = DerbyStorage.getInstance(DB_NAME);
            } catch (Exception e) {
                JOptionPane.showMessageDialog(this, e.getMessage());
                storage = oldStorage;
            }

            universe = storage.getLastVisited();

            // then delete selected db
            if (!storage.deleteDB(delDB)) {
                JOptionPane.showMessageDialog(this, "Failed to delete database!");
            }

            loadForm(true);
        }
}//GEN-LAST:event_jMenuItemDeleteDBActionPerformed

    private void jMenuItemExportDBActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemExportDBActionPerformed
        // first offer to save current universe if it needs it
        if (checkAndSave()) {

            JFileChooser fc = new JFileChooser();

            fc.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
            fc.setDialogTitle("Select directory for database export.");

            // Get users 'My Documents' path
            File outputDir = new File(FileSystemView.getFileSystemView().getDefaultDirectory().getPath() + "\\.");
            fc.setSelectedFile(outputDir);

            int returnVal = fc.showSaveDialog(this);
            if (returnVal == JFileChooser.APPROVE_OPTION) {
                outputDir = fc.getSelectedFile();
                if (storage.exportDB(outputDir.getPath())) {
                    JOptionPane.showMessageDialog(this, "Database exported successfully!");
                }
            }
        }
}//GEN-LAST:event_jMenuItemExportDBActionPerformed

    private void jMenuItemImportDBActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemImportDBActionPerformed
        // first offer to save current universe if it needs it
        if (checkAndSave()) {

            JFileChooser fc = new JFileChooser();

            fc.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
            fc.setDialogTitle("Select database directory for import.");

            // Get users 'My Documents' path
            File inputDir = new File(FileSystemView.getFileSystemView().getDefaultDirectory().getPath() + "\\.");
            fc.setSelectedFile(inputDir);

            int returnVal = fc.showOpenDialog(this);
            if (returnVal == JFileChooser.APPROVE_OPTION) {
                inputDir = fc.getSelectedFile();
                String nm = inputDir.getName();

                // list all databases
                ArrayList dbList = storage.getDBAvailableList(false);
                for (int i = 0; i < dbList.size(); i++) {
                    if (((String[])dbList.get(i))[1].equals(nm)) {
                        if (JOptionPane.showConfirmDialog(this,
                                "Database " + nm + " already exists\n" +
                                "Do you wish to replace it?",
                                "Replace Database?",
                                JOptionPane.YES_NO_OPTION) == JOptionPane.NO_OPTION) {
                            return;
                        }
                    }
                }
                Storage oldStorage = storage;
                try {
                    storage = DerbyStorage.getInstance(inputDir.getPath());
                } catch (Exception e) {
                    JOptionPane.showMessageDialog(this, e.getMessage());
                    storage = oldStorage;
                }

                universe = storage.getLastVisited();

                loadForm(true);
            }
        }
}//GEN-LAST:event_jMenuItemImportDBActionPerformed

    private void jMenuItemExitActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemExitActionPerformed
        if (checkAndSave()) {
            DerbyStorage.shutdownDB();
            System.exit(1);
        }
}//GEN-LAST:event_jMenuItemExitActionPerformed

    private void jMenuItemGenerateRActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemGenerateRActionPerformed
        if (!saveOpposingForm()) return;

        if (universe.getShortName().equals("")) {
            JOptionPane.showMessageDialog(this, "Universe must be named first!");
            return;
        }

        DefaultMutableTreeNode node = (DefaultMutableTreeNode)jTreeUniverse.getLastSelectedPathComponent();

        /* retrieve the node that was selected */
        Object obj = null;
        if (node != null) obj = node.getUserObject();
        if (obj == null || (!(obj instanceof Universe) && !(obj instanceof Element))) {
            JOptionPane.showMessageDialog(this, "Please select either the universe or a single element!");
            return;
        }

        // Validate
        boolean passed = true;
        setProgress("Validating object...");
        if (obj instanceof Universe) passed = ((Universe)obj).validate(true);
        if (obj instanceof Element) passed = ((Element)obj).validate(universe, true);
        if (!passed) {
            if (JOptionPane.showConfirmDialog(this, "Object failed to pass validation!\n"
                        + Messages.getUnreadErrMsgs() + "\n"
                        + "Do you wish to continue?", "Failed validation", JOptionPane.YES_NO_OPTION) == JOptionPane.NO_OPTION) {
                endProgress();
                return;
            }
        }

        // Generate
        setProgress("Generating R code...");
        writeAsR((EPOCObject)obj);
        endProgress();
}//GEN-LAST:event_jMenuItemGenerateRActionPerformed

    private void jMenuItemTextEditorActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemTextEditorActionPerformed

        RJEditor rje = new RJEditor();
}//GEN-LAST:event_jMenuItemTextEditorActionPerformed

    private void jMenuItemTimelineActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemTimelineActionPerformed
        setProgress("Creating timeline...");
        TimelineUI tl = new TimelineUI(universe);
        tl.setVisible(true);
        endProgress();
}//GEN-LAST:event_jMenuItemTimelineActionPerformed

    private void jMenuItemValidateActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemValidateActionPerformed
        if (!saveOpposingForm()) return;

        DefaultMutableTreeNode node = (DefaultMutableTreeNode)
                       jTreeUniverse.getLastSelectedPathComponent();

        // retrieve the node that was selected
        Object nodeObject = null;
        if (node != null) nodeObject = node.getUserObject();

        if (nodeObject != null && (nodeObject instanceof Universe || nodeObject instanceof Element
                || nodeObject instanceof Action || nodeObject instanceof Attribute)) {
            //ValidationUI valUI = new ValidationUI();
            //jSplitPane1.setRightComponent(valUI);
            //valUI.setVisible(true);
            setProgress("Validating...");
            RJEditor rje = new RJEditor();
            rje.setTitle("Validation report (" + ((EPOCObject)nodeObject).getDisplayName() + ")");
            ValidationWorker vw = null;
            if (nodeObject instanceof Universe) {
                vw = new ValidationWorker(this, rje, universe);
            } else if (nodeObject instanceof Element) {
                vw = new ValidationWorker(this, rje, universe, (Element)nodeObject);
            } else if (nodeObject instanceof Action) {
                vw = new ValidationWorker(this, rje, universe, getAncestorElement(node), (Action)nodeObject);
            } else if (nodeObject instanceof Attribute) {
                vw = new ValidationWorker(this, rje, universe, getAncestorElement(node), (Attribute)nodeObject);
            }
            if (vw != null) vw.execute();
            endProgress();
        } else {
            JOptionPane.showMessageDialog(this, "Please select a valid EPOC object!");
        }
}//GEN-LAST:event_jMenuItemValidateActionPerformed

    private void jMenuItemOptionsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemOptionsActionPerformed
        if (!saveOpposingForm()) return;

        jTreeUniverse.clearSelection();
        OptionsUI optUI = new OptionsUI();
        optUI.editable(true);
        jSplitPane1.setRightComponent(optUI);
        optUI.setVisible(true);
}//GEN-LAST:event_jMenuItemOptionsActionPerformed

    private void jMenuItemAboutActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemAboutActionPerformed
        JOptionPane.showMessageDialog(this, "EPOC Builder\n\n" +
                "Element management tool and R code generator for:\n" +
                "Ecosystem Productivity Ocean and Climate\n" +
                "Coupled Ocean Ecology Model System\n\n" +
                "Version: " + EPOC_VER + "\n" +
                "2010", "EPOC Builder", JOptionPane.INFORMATION_MESSAGE);
}//GEN-LAST:event_jMenuItemAboutActionPerformed

    private void formWindowClosing(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosing
        if (checkAndSave()) {
            DerbyStorage.shutdownDB();
            System.exit(1);
        }
    }//GEN-LAST:event_formWindowClosing

    private void jMenuItemRefreshActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemRefreshActionPerformed
        if (!saveOpposingForm()) return;

        reloadTree();
    }//GEN-LAST:event_jMenuItemRefreshActionPerformed

    private void jMenuItemRunActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemRunActionPerformed
        boolean dirSuccess = true;
        JFileChooser fc = new JFileChooser();

        ExtensionFileFilter ff = new ExtensionFileFilter();
        ff.addType("R");
        ff.setDescription("R Files");
        fc.addChoosableFileFilter(ff);
        fc.setAcceptAllFileFilterUsed(false);
        fc.setDialogTitle("Select EPOC run script");
        fc.setApproveButtonText("Run");
        fc.setFileSelectionMode(JFileChooser.FILES_ONLY);

        // Get users 'My Documents' path
        String newPath = (!lastPath.equals("") ? lastPath : FileSystemView.getFileSystemView().getDefaultDirectory().getPath()) + File.separatorChar + "Run_EPOC.R";
        if (EPOC_DBG) System.out.println(newPath);
        File runFile = new File(newPath);
        fc.setSelectedFile(runFile);

        int returnVal = fc.showOpenDialog(this);
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            runFile = fc.getSelectedFile();

            // make sure run script and subdirectories exist
            if (!runFile.isFile() || !runFile.exists()) dirSuccess = false;
            if (!(new File(runFile.getParent() + File.separator + "code")).exists()) dirSuccess = false;
            if (!(new File(runFile.getParent() + File.separator + "data")).exists()) dirSuccess = false;

            if (!dirSuccess) {
                JOptionPane.showMessageDialog(this, "Make sure selected EPOC run script exists and that 'code' and/or \n" +
                                                    "'data' subdirectories exists and contain generated R code\n" +
                                                    "in EPOC HOME directory: " + runFile.getPath());
                return;
            }
            lastPath = runFile.getParent();

            // And run the controller to produce a calendar
            setProgress("Running EPOC Controller...");
            String outfilePath = runFile.getParent() + File.separatorChar + "EPOC execution.Rout";
            RBatchWorker rbw = new RBatchWorker(this, runFile.getPath(), outfilePath);
            rbw.setAltPublishTitle("EPOC Output (" + universe.getDisplayName() + ")");
            rbw.execute();
        }
    }//GEN-LAST:event_jMenuItemRunActionPerformed

    /**
     * Prompt for location of XML file containing EPOC object and import it as
     * a template
     * @param evt
     */
    private void jMenuItemImportXMLActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemImportXMLActionPerformed
        if (!saveOpposingForm()) return;

        String errMess = "";
        EPOCObject comparableObj = null;

        setProgress("Importing XML...");
        EPOCObject importObj = XMLReaderWriter.getInstance().importXML(this);
        if (importObj == null) {           
            if (!(errMess = Messages.getUnreadErrMsgs()).equals("")) {
                JOptionPane.showMessageDialog(this, errMess, "Import Failed", JOptionPane.ERROR_MESSAGE);
            }
            endProgress();
            return;
        }

        if (EPOC_AUTO_MATCH_MEMBERS) comparableObj = universe.findComparableTemplateObject(importObj);
        if (comparableObj != null) {
            setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
            if (JOptionPane.showConfirmDialog(this, "Comparable template object '" + comparableObj.getDisplayName() + "' already exists!\n"
                                              + "Do you still wish to continue import of " + importObj.getDisplayName() + "?",
                                              "Comparable Template Object Exists", JOptionPane.YES_NO_OPTION) == JOptionPane.NO_OPTION) {
                endProgress();
                return;
            }
            setCursor(new Cursor(Cursor.WAIT_CURSOR));
        }

        universe.addImportedTemplate(importObj);
        endProgress();

        // Should now work out which template list to select in tree view?
        valueChanged(null);
    }//GEN-LAST:event_jMenuItemImportXMLActionPerformed

    private void jMenuItemRationaliseActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemRationaliseActionPerformed
        if (!saveOpposingForm()) return;

        JOptionPane.showMessageDialog(this, "Not implemented yet");
    }//GEN-LAST:event_jMenuItemRationaliseActionPerformed

    private void jMenuItemGenerateCalendarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemGenerateCalendarActionPerformed
        if (!saveOpposingForm()) return;
        
        if (universe.getShortName().equals("")) {
            JOptionPane.showMessageDialog(this, "Universe must be named first!");
            return;
        }

        // Validate
        setProgress("Validating Universe...");
        
        if (!universe.validate(true)) {
        //if (!validateUniverse()) {
            setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
            if (JOptionPane.showConfirmDialog(this, "Universe failed to pass validation!\n"
                        + Messages.getUnreadErrMsgs() + "\n"
                        + "Do you wish to continue?", "Failed validation", JOptionPane.YES_NO_OPTION) == JOptionPane.NO_OPTION) {
                return;
            }
            setCursor(new Cursor(Cursor.WAIT_CURSOR));
        }

        // Get users temp path
        String tmpPath = System.getProperty("java.io.tmpdir") + File.separatorChar + "EPOC";

        // make sure subdirectories exist
        boolean dirSuccess = true;
        if (!(new File(tmpPath)).exists()) {
            if (!(new File(tmpPath)).mkdir()) dirSuccess = false;
        }
        if (!(new File(tmpPath + File.separator + "code")).exists()) {
            if (!(new File(tmpPath + File.separator + "code")).mkdir()) dirSuccess = false;
        }
        if (!(new File(tmpPath + File.separator + "data")).exists()) {
            if (!(new File(tmpPath + File.separator + "data")).mkdir()) dirSuccess = false;
        }
        if (!dirSuccess) {
            endProgress();
            JOptionPane.showMessageDialog(this, "'code' and/or 'data' subdirectories were not able to be created\n" +
                                                "in EPOC HOME directory: " + tmpPath + File.separator + "EPOC");
            return;
        }

        // Okay now start writing R code/data and run script
        setProgress("Writing universe as R code...");
        universe.writeAsR(tmpPath, true);
        File runFile = universe.writeRunScript(tmpPath, false, true);

        // And run the controller to produce a calendar
        setProgress("Running EPOC controller to build calendar...");
        String outfilePath = runFile.getParent() + File.separator + "EPOC calendar.Rout";
        RBatchWorker rbw = new RBatchWorker(this, runFile.getPath(), outfilePath);
        String calFilename = "Calendar.txt";
        if (universe.getReport() != null && universe.getReport().getCalendarFilename().equals("")) {
            calFilename = universe.getReport().getCalendarFilename();
        }
        rbw.setAltPublishPath(tmpPath + File.separator + "runtime" + File.separator + calFilename);
        rbw.setAltPublishTitle("EPOC Calendar (" + universe.getDisplayName() + ")");
        rbw.execute();
    }//GEN-LAST:event_jMenuItemGenerateCalendarActionPerformed

    private void jMenuItemRepairActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemRepairActionPerformed
        if (!saveOpposingForm()) return;

        DefaultMutableTreeNode node = (DefaultMutableTreeNode)
                       jTreeUniverse.getLastSelectedPathComponent();

        // retrieve the node that was selected
        Object nodeObject = null;
        if (node != null) nodeObject = node.getUserObject();

        setProgress("Repairing links...");
        if (nodeObject != null && nodeObject instanceof EPOCObject) {
            ((EPOCObject)nodeObject).repairBrokenLinks(universe, getAncestorElement(node));
        } else {
            JOptionPane.showMessageDialog(this, "Please select a valid EPOC object!");
        }
        endProgress();
        valueChanged(null);
    }//GEN-LAST:event_jMenuItemRepairActionPerformed

    private void jTreeUniverseKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jTreeUniverseKeyReleased
       if (evt.isAltDown() && evt.getKeyCode() == KeyEvent.VK_UP) {
           upObjectActionPerformed(null);
       }
    }//GEN-LAST:event_jTreeUniverseKeyReleased

    /**
     * TODO Could add checkboxes and Delete/Template buttons
     * @param evt
     */
    private void jMenuItemOrphansActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemOrphansActionPerformed
        ArrayList orphList;
        String txt;

        txt = "Orphaned EPOC Builder database objects:";
        orphList = storage.getOrphanedList(OBJ_ALL);

        ListSelectorUI selUI = new ListSelectorUI(txt, orphList);
        final JOptionPane pane = new JOptionPane(selUI, JOptionPane.QUESTION_MESSAGE,
                JOptionPane.OK_CANCEL_OPTION);
        JDialog dialog = pane.createDialog(this, "Orphaned Objects");
        dialog.setLocationRelativeTo(this);
        dialog.pack();
        dialog.setVisible(true);
    }//GEN-LAST:event_jMenuItemOrphansActionPerformed

    /**
     * Check if there have been any modifications to the Universe or templates.
     * If so, prompt to save back to storage.
     * @return success
     */
    private boolean checkAndSave() {
        String txt;
        boolean retVal = true;
        boolean uniMod = false, templMod = false;

        if (!saveOpposingForm()) return false;

        setProgress("Checking for changes...");
        if (!universe.isEmpty()) uniMod = (!universe.compare(storedUni, false));
        templMod = (!universe.getTemplates().compare(storedUni.getTemplates()));
        endProgress();

        if (uniMod) {
            txt = "Save Universe, superhero?";
        } else {
            txt = "Save template changes?";
        }

        if (uniMod || templMod) {

            Object[] options = {"Yes", "No", "Cancel"};
            int choice = JOptionPane.showOptionDialog(this, txt, "Save",
                            JOptionPane.YES_NO_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null,
                            options, options[0]);

            if (choice == JOptionPane.YES_OPTION) {
                // Warn about any broken links
                if (universe.hasBrokenLink()) {
                    if (JOptionPane.showConfirmDialog(this, "Universe contains one or more broken links!\n"
                                + "These will not have their context saved.\n"
                                + "Use the Validation tool to find all broken links!\n\n"
                                + "Do you wish to continue with save?", "Broken Links", JOptionPane.YES_NO_OPTION) == JOptionPane.NO_OPTION) {
                        return false;
                    }
                }

                setProgress("Saving to database...");

                // Save the universe to storage
                if (uniMod && !universe.saveToStorage()) retVal = false;

                // finally save any unused templates in case they were templated and then unlinked
                // in the same session (eg will be in template list with a uid but not in an object list
                if (!universe.saveUnusedTemplateObjects()) retVal = false;
                
                endProgress();
                if (!retVal) JOptionPane.showMessageDialog(this, Messages.getUnreadErrMsgs(), "Error", JOptionPane.ERROR_MESSAGE);
            } else if (choice == JOptionPane.CANCEL_OPTION) {
                endProgress();
                return false;
            }
        }

        saveSettings();

        return retVal;
    }

    /**
     * Reload the tree from the universe data members
     */
    private void reloadTree() {
        jTreeUniverse.setModel(buildTreeModel());
        // TODO get opened and selected objects and reinstate them
        jTreeUniverse.setSelectionRow(0);
    }

    /**
     * Build a tree model representing the universe data members.
     * @return universe tree model
     */
    private DefaultTreeModel buildTreeModel() {

        // Create universe tree node
        DefaultMutableTreeNode rootNode = new DefaultMutableTreeNode(universe);
        rootNode.add(loadUniverseConfig());
        rootNode.add(loadModule(OBJ_BIO));
        rootNode.add(loadModule(OBJ_ENV));
        rootNode.add(loadModule(OBJ_ATY));
        rootNode.add(loadModule(OBJ_MAN));
        rootNode.add(loadModule(OBJ_OUT));
        rootNode.add(loadModule(OBJ_PRE));

        DefaultTreeModel treeModel = new DefaultTreeModel(rootNode);
        treeModel.addTreeModelListener(new UniverseTreeModelListener());

        return treeModel;
    }

    /**
     * Create new configuration node.  Add any Spatial, Report and Trial
     * data members as child nodes.
     * @param rootNode
     * @return config node
     */
    private DefaultMutableTreeNode loadUniverseConfig() {

        // Create a config title node
        DefaultMutableTreeNode configNode = new DefaultMutableTreeNode("Configuration");
        loadConfigObjects(configNode);

        return configNode;
    }

    /**
     * Method to do the actual loading of the configuration type objects.
     * This may be called to reload these data members as nodes.
     * @param configNode
     */
    private void loadConfigObjects(DefaultMutableTreeNode configNode) {

        if (universe.getSpatial() != null) {
            configNode.add(new DefaultMutableTreeNode(universe.getSpatial()));
        } else {
            configNode.add(new DefaultMutableTreeNode("Spatial"));
        }
        if (universe.getReport() != null) {
            configNode.add(new DefaultMutableTreeNode(universe.getReport()));
        } else {
            configNode.add(new DefaultMutableTreeNode("Report"));
        }

        //DefaultMutableTreeNode trialsNode = new DefaultMutableTreeNode("Trials");
        boolean hasTrial = false;
        for (Trial tri : universe.getTrials()) {
            //trialsNode.add(new DefaultMutableTreeNode(tri));
            configNode.add(new DefaultMutableTreeNode(tri));
            hasTrial = true;
        }
        if (!hasTrial) configNode.add(new DefaultMutableTreeNode("Trial"));
        //configNode.add(trialsNode);
    }

    /**
     * Create new Element module node of the Element type passed.
     * Add any element data members of that type as sub nodes to the module node.
     * @param rootNode
     * @return module node
     */
    private DefaultMutableTreeNode loadModule(int eleType) {
        // Create a module title node
        DefaultMutableTreeNode moduleNode = new DefaultMutableTreeNode(EPOCObject.getObjectTypeName(eleType).toUpperCase());

        ArrayList eleList = universe.getElements(eleType);

        // create all element nodes for the module
        for (Object ele : eleList) {
            moduleNode.add(loadElement((Element)ele));
        }

        return moduleNode;
    }

    /**
     * Load the passed Element as a tree node with all Attributes and Actions
     * attached as child nodes.
     * @param ele
     * @return element node
     */
    private DefaultMutableTreeNode loadElement(Element ele) {
        DefaultMutableTreeNode elementNode = new DefaultMutableTreeNode(ele);

        // Load any attributes
        DefaultMutableTreeNode attributeNode = new DefaultMutableTreeNode("Attributes");
        for (Attribute att : ele.getAttributes()) {
            attributeNode.add(new DefaultMutableTreeNode(att));
        }
        elementNode.add(attributeNode);

        // Load any actions
        DefaultMutableTreeNode actionNode = new DefaultMutableTreeNode("Actions");
        for (Action act : ele.getActions()) {
            actionNode.add(new DefaultMutableTreeNode(act));
        }
        elementNode.add(actionNode);

        return elementNode;
    }

    /**
     * Call on user to select path to have obj write itself out to as R code.
     * Default path is My Documents or /home directory
     * @param obj
     */
    private void writeAsR(EPOCObject obj) {
        boolean dirSuccess = true;
        JFileChooser fc = new JFileChooser();

        fc.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
        if (obj instanceof Universe || obj instanceof Element) {
            fc.setDialogTitle("Select EPOC HOME directory.");
        } else {
            return;
        }

        // Get users 'My Documents' path
        String newPath = (!(lastPath.equals("")) ? lastPath : FileSystemView.getFileSystemView().getDefaultDirectory().getPath() + File.separatorChar);
        File outputFile = new File(newPath);
        fc.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
        fc.setCurrentDirectory(outputFile);
        //fc.setSelectedFile(outputFile);

        int returnVal = fc.showSaveDialog(this);
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            outputFile = fc.getSelectedFile();

            // make sure subdirectories exist
            if (!(new File(outputFile.getPath() + File.separator + "code")).exists()) {
                if (!(new File(outputFile.getPath() + File.separator + "code")).mkdir()) dirSuccess = false;
            }
            if (!(new File(outputFile.getPath() + File.separator + "data")).exists()) {
                if (!(new File(outputFile.getPath() + File.separator + "data")).mkdir()) dirSuccess = false;
            }
            if (!dirSuccess) {
                JOptionPane.showMessageDialog(this, "'code' and/or 'data' subdirectories were not able to be created\n" +
                                                    "in EPOC HOME directory: " + outputFile.getPath());
                return;
            }
            lastPath = outputFile.getPath();

            if (obj instanceof Universe) {
                // Write Universe out to file
                universe.writeAsR(outputFile.getPath(), true);
                JOptionPane.showMessageDialog(this, "Universe written to file successfully.");

            } else {
                // Just write out a single element to file
                ((Element)obj).writeAsR(outputFile.getPath());
                JOptionPane.showMessageDialog(this, "Element written to file successfully.");
            }
        }
    }

    /**
     * Recursive call back up tree searching for ancestor node which is an Element
     * @param node
     * @return
     */
    private Element getAncestorElement(DefaultMutableTreeNode node) {
        try {
            Object pNode = ((DefaultMutableTreeNode)node.getParent()).getUserObject();
            if (pNode instanceof Universe) return null;
            if (pNode instanceof Element) return (Element)pNode;
            return getAncestorElement((DefaultMutableTreeNode)node.getParent());
        } catch (Exception e) {
            return null;
        }
    }

    private Element reviseAncestorElement(DefaultMutableTreeNode node) {
        // need to revise parent element too if it was a template
        Element pEle = getAncestorElement(node);
        Element modEle = pEle;

        if (pEle != null && pEle.isTemplate()) {

            modEle = (Element)pEle.clone();
            universe.replaceModifiedElement(pEle, modEle);

            // update both tree nodes
            setAncestorElement(node, modEle);
        }

        return modEle;
    }

    private void setAncestorElement(DefaultMutableTreeNode node, Element newEle) {
        try {
            Object pNode = ((DefaultMutableTreeNode)node.getParent()).getUserObject();
            if (pNode instanceof Universe) return;
            if (pNode instanceof Element) {
                ((DefaultMutableTreeNode)node.getParent()).setUserObject(newEle);
                ((DefaultTreeModel)jTreeUniverse.getModel()).nodeChanged(node.getParent());
                return;
            }
            setAncestorElement((DefaultMutableTreeNode)node.getParent(), newEle);
        } catch (Exception e) {
            return;
        }
    }

    /**
     * Public method allowing tree node updates to be instigated by actions in the right pane
     * Refreshes children of the currently selected node.
     * @param newChild
     */
    public void reloadConfigNodes() {

        currentTreeNode.removeAllChildren();
        loadConfigObjects(currentTreeNode);
        ((DefaultTreeModel)jTreeUniverse.getModel()).nodeStructureChanged(currentTreeNode);
      
        jTreeUniverse.expandPath(currentTreePath);
    }

    /**
     * Public method allowing tree inserts to be instigated by actions in the right pane
     * Inserts a new node as a child of the currently selected node.
     * If node object is an Element then loadElement is called to load its Actions / Attributes
     * @param newChild
     */
    public DefaultMutableTreeNode insertAsLastChildOfSelected(EPOCObject newChild) {
        DefaultMutableTreeNode newNode = null;
        DefaultMutableTreeNode parentNode = currentTreeNode;

        if (newChild instanceof Element) {
             newNode = loadElement((Element)newChild);
        } else if (newChild instanceof Action || newChild instanceof Attribute) {
            // Attribute or Action
            newNode = new DefaultMutableTreeNode(newChild);
        } else if (newChild instanceof Trial) {
            // bit of a twist for Trials as a trial is selected for 'Add New' rather
            // than its parent
            newNode = new DefaultMutableTreeNode(newChild);
            parentNode = (DefaultMutableTreeNode)currentTreeNode.getParent();
        }

        if (newNode != null) insertAsLastChildOf(parentNode, newNode);
        jTreeUniverse.expandPath(currentTreePath);

        return newNode;
    }

    /**
     * Insert newChild node as a new child of parent node in the last position.
     * @param parent
     * @param newChild
     * @return index child was inserted at
     */
    private int insertAsLastChildOf(DefaultMutableTreeNode parent, DefaultMutableTreeNode newChild) {
        int childCnt = ((DefaultTreeModel)jTreeUniverse.getModel()).getChildCount(parent);
        ((DefaultTreeModel)jTreeUniverse.getModel()).insertNodeInto(newChild, parent, childCnt);

        return childCnt;
    }

    /**
     * Call on the opposing form to save itself if modified.  If it was a template
     * (and therefore a clone) then replace the original data member with this
     * modified one.  Fires tree model nodeChanged event for a tree node update.
     * @return success
     */
    private boolean saveOpposingForm() {
        if (!(jSplitPane1.getRightComponent() instanceof JButton) && jSplitPane1.getRightComponent() != null) {
            int retVal = ((OpposingPanelUI)jSplitPane1.getRightComponent()).saveIfModified();

            if (retVal == EPOC_SUCC) {
                DefaultMutableTreeNode modifiedNode = currentTreeNode;

                if (((OpposingPanelUI)jSplitPane1.getRightComponent()).getObject() != null) {
                    EPOCObject modObject = ((OpposingPanelUI)jSplitPane1.getRightComponent()).getObject();
                    EPOCObject origObject = (EPOCObject)currentTreeNode.getUserObject();
                    if (modObject.isTemplate()) {
                        if (EPOC_EDIT_TEMPL && (JOptionPane.showConfirmDialog(this, "Do you wish to modify template without revision?\n" +
                                                                                    "This will change this object everywhere it is in use!",
                                "Revise", JOptionPane.YES_NO_OPTION) == JOptionPane.YES_OPTION)) {
                            modifiedNode = updateModifiedEPOCTemplateObject(modObject);
                        } else {
                            // check that template is not a linked object
                            boolean isLinked = universe.isLinked(origObject);
                            if ((origObject instanceof Action || origObject instanceof Attribute)
                                    && universe.isLinked(getAncestorElement(currentTreeNode))) isLinked = true;
                            if (isLinked) {
                                if (JOptionPane.showConfirmDialog(this, "Revising this template will create broken links!\n"
                                                                      + "Revise anyway?",
                                            "Broken Links", JOptionPane.YES_NO_OPTION) == JOptionPane.NO_OPTION) {
                                    return true;
                                }
                            }
                            modifiedNode = replaceModifiedEPOCTemplateObject(modObject);
                        }
                        ((DefaultTreeModel)jTreeUniverse.getModel()).nodeChanged(modifiedNode);
                    } else if (modObject instanceof Spatial || modObject instanceof Report || modObject instanceof Trial) {
                        if ((currentTreeNode.getUserObject() instanceof String)) {
                            universe.setNewConfigObject(modObject);
                            ((DefaultMutableTreeNode)currentTreeNode).setUserObject(modObject);
                        }
                    }
                }

                ((DefaultTreeModel)jTreeUniverse.getModel()).nodeChanged(currentTreeNode);
            } else if (retVal == EPOC_FAIL) {
                // if failed save then there is a problem with input data so keep it on this node
                //jTreeUniverse.setSelectionPath(currentTreePath);
                return false;
            }
        }

        return true;
    }

    /**
     * Keep the existing selected tree epoc object but update its data members with those
     * from the modified object passed
     * @param modObject
     * @return
     */
    private DefaultMutableTreeNode updateModifiedEPOCTemplateObject(EPOCObject modObject) {
        // check that config is not currently empty
        if (!(currentTreeNode.getUserObject() instanceof String)) {
            EPOCObject origObject = (EPOCObject)currentTreeNode.getUserObject();
            origObject.updateDataMembersFrom(modObject);
        }

        return currentTreeNode;
    }
    
    /**
     * Replace the currently selected universe object with the edited copy passed
     * and then replace the object in the tree.  If a templated attribute or action
     * is a member of a templated element then that element will be revised too.
     * Returns the highest level node modified.
     * NOTE: This will make calls which will update version of new object if it was
     *        originally a template and un-template it
     *
     * @param modObject]
     * @return DefaultMutableTreeNode
     */
    private DefaultMutableTreeNode replaceModifiedEPOCTemplateObject(EPOCObject modObject) {
        if (currentTreeNode.getUserObject() == null
                || !(currentTreeNode.getUserObject() instanceof EPOCObject)) {
            return null;
        }

        EPOCObject origObj = (EPOCObject)currentTreeNode.getUserObject();
        if (modObject instanceof Spatial || modObject instanceof Report || modObject instanceof Trial) {
            // check that config is not currently empty
            if (!(currentTreeNode.getUserObject() instanceof String)) {
                universe.replaceModifiedConfig(origObj, modObject);
                ((DefaultMutableTreeNode)currentTreeNode).setUserObject(modObject);
            }
        } else if (modObject instanceof Element) {
            universe.replaceModifiedElement((Element)origObj, (Element)modObject);
            ((DefaultMutableTreeNode)currentTreeNode).setUserObject(modObject);
        } else if (modObject instanceof Action || modObject instanceof Attribute) {
            // revise parent element (if it is a template)
            Element pEle = reviseAncestorElement(currentTreeNode);
            // and revise/replace attribute or action
            pEle.replaceModifiedActAtt(origObj, modObject, universe);
            ((DefaultMutableTreeNode)currentTreeNode).setUserObject(modObject);
        }

        return currentTreeNode;
    }


    // EVENT HANDLERS
    /****************************************************************************************************/
    /**
     * Implements required method for TreeSelectionListener
     * @param e
     */
    public void valueChanged(TreeSelectionEvent tse) {
        DefaultMutableTreeNode node = (DefaultMutableTreeNode)
                       jTreeUniverse.getLastSelectedPathComponent();

        // if nothing is selected
        if (node == null) return;
        int dl = jSplitPane1.getDividerLocation();

        // retrieve the node that was selected
        Object nodeObject = node.getUserObject();
        // process node type to determine the action to be taken
        if (nodeObject instanceof String) {
            if (nodeObject.equals("Configuration")) {
                OpposingPanelUI cluster = new OpposingPanelUI();
                cluster.setLayout(new GridLayout(3,1));
                cluster.add(new TemplateUI(this, universe, OBJ_SPA), 0);
                cluster.add(new TemplateUI(this, universe, OBJ_REP), 1);
                cluster.add(new TemplateUI(this, universe, OBJ_TRI), 2);
                jSplitPane1.setRightComponent(cluster);
            } else if (nodeObject.equals("Spatial")) {
                jSplitPane1.setRightComponent(new SpatialUI(new Spatial(), universe));
            } else if (nodeObject.equals("Report")) {
                jSplitPane1.setRightComponent(new ReportUI(new Report(), universe));
            } else if (nodeObject.equals("Trial")) {
                jSplitPane1.setRightComponent(new TrialUI(new Trial(), universe));
            } else if (Element.isModuleTypeName((String)nodeObject)) { // An element type group is selected
                OpposingPanelUI cluster = new OpposingPanelUI();
                cluster.setLayout(new GridLayout(2,1));
                cluster.add(new TemplateUI(this, universe, Element.getModuleTypeFromName((String)nodeObject)), 0);
                cluster.add(new TemplateUI(this, universe, OBJ_CLS, Element.getModuleTypeFromName((String)nodeObject)), 1);
                jSplitPane1.setRightComponent(cluster);
                //jSplitPane1.setRightComponent(new TemplateUI(this, universe, Element.getModuleTypeFromName((String)nodeObject)));
            } else if (nodeObject.equals("Actions")) {
                jSplitPane1.setRightComponent(new TemplateUI(this, universe, getAncestorElement(node), OBJ_ACT));
            } else if (nodeObject.equals("Attributes")) {
                jSplitPane1.setRightComponent(new TemplateUI(this, universe, getAncestorElement(node), OBJ_ATT));
            }
        } else if (nodeObject instanceof EPOCObject) {
            if (((EPOCObject)nodeObject).isTemplate()) {
                editObject = ((EPOCObject)nodeObject).clone();
            } else {
                editObject = (EPOCObject)nodeObject;
            }
            if (nodeObject instanceof Universe) {
                jSplitPane1.setRightComponent(new UniverseUI(universe));
            } else if (nodeObject instanceof Spatial) {
                jSplitPane1.setRightComponent(new SpatialUI((Spatial)editObject, universe));
            } else if (nodeObject instanceof Report) {
                jSplitPane1.setRightComponent(new ReportUI((Report)editObject, universe));
            } else if (nodeObject instanceof Trial) {
                jSplitPane1.setRightComponent(new TrialUI((Trial)editObject, universe));
            } else if (nodeObject instanceof Element) {
                jSplitPane1.setRightComponent(new ElementUI((Element)editObject, universe));
            } else if (nodeObject instanceof Action) {
                jSplitPane1.setRightComponent(new ActionUI((Action)editObject, getAncestorElement(node), universe));
            } else if (nodeObject instanceof Attribute) {
                jSplitPane1.setRightComponent(new AttributeUI((Attribute)editObject, getAncestorElement(node)));
            }
        }

        // store state information
        jSplitPane1.setDividerLocation(dl);
        currentTreePath = jTreeUniverse.getSelectionPath();
        currentTreeNode = node;

        jTreeUniverse.repaint();
    }

    /**
     * Swap selected node with its preceding node and refresh tree model
     * @param evt
     */
    public void upObjectActionPerformed(java.awt.event.ActionEvent evt) {
        EPOCObject selObj;

        DefaultMutableTreeNode node = (DefaultMutableTreeNode)jTreeUniverse.getLastSelectedPathComponent();

        try {
            selObj = (EPOCObject)node.getUserObject();
            if (selObj instanceof Universe) throw new Exception();
        } catch (Exception e) {
            JOptionPane.showMessageDialog(this, "An EPOC object must be selected first!");
            return;
        }

        // Check if a save is needed first
        if (!saveOpposingForm()) return;

        // Then select parent tree node
        int selIdx = node.getParent().getIndex(node);
        if ((!(selObj instanceof Trial) && selIdx > 0) || (selObj instanceof Trial && selIdx > 2)) {
            
            EPOCObject prevObj = (EPOCObject)((DefaultMutableTreeNode)node.getParent().getChildAt(selIdx - 1)).getUserObject();

            Element parentEle = null;
            if ((parentEle = getAncestorElement(node)) != null) {
                parentEle.swapIndexes(prevObj, selObj);
            } else {
                universe.swapIndexes(prevObj, selObj);
            }

            // modify tree model
            ((DefaultMutableTreeNode)node.getParent()).insert(node, selIdx - 1);

            // And refresh tree node
            ((DefaultTreeModel)jTreeUniverse.getModel()).nodesChanged(node.getParent(), new int[]{selIdx - 1, selIdx});
            // if element then refresh child nodes
            if (selObj instanceof Element) {
                ((DefaultTreeModel)jTreeUniverse.getModel()).nodeStructureChanged(node.getParent());
            }

            // reselect original object
            jTreeUniverse.setSelectionPath(currentTreePath.getParentPath().pathByAddingChild(node));

            jTreeUniverse.repaint();
        }
    }

    /**
     * Copy the selected object to the clipboard.
     * @param evt
     */
    public void copyObjectActionPerformed(java.awt.event.ActionEvent evt) {
        EPOCObject selObj;

        // retrieve the node that was selected
        DefaultMutableTreeNode node = (DefaultMutableTreeNode)jTreeUniverse.getLastSelectedPathComponent();
        try {
            selObj = (EPOCObject)node.getUserObject();
            if (selObj instanceof Universe) throw new Exception();
            clipboardObject = selObj;
        } catch (Exception e) {
            JOptionPane.showMessageDialog(this, "An EPOC object must be selected first!");
            return;
        }
    }

    /**
     * Paste the clipboard object as a new child object of the selected node,
     * but only if the class makes sense.
     * @param evt
     */
    public void pasteObjectActionPerformed(java.awt.event.ActionEvent evt) {
        EPOCObject newObject = null;

        if (clipboardObject != null) {

            // retrieve the node that was selected
            DefaultMutableTreeNode node = (DefaultMutableTreeNode)jTreeUniverse.getLastSelectedPathComponent();
            // and then the node object
            Object nodeObject = node.getUserObject();

            // check if it is sensible to paste clipboard object under this node
            if ((nodeObject.equals("BIOTA") || nodeObject.equals("ENVIRONMENT")
                    || nodeObject.equals("ACTIVITY") || nodeObject.equals("MANAGEMENT")
                    || nodeObject.equals("OUTPUT") || nodeObject.equals("PRESENTATION"))
                    && !(clipboardObject instanceof Element)) {
                JOptionPane.showMessageDialog(this, "An Element may only be copied into an element module!");
                return;
            } else if ((nodeObject.equals("Actions") || nodeObject.equals("Attributes"))
                    && !((clipboardObject.getObjectTypeName() + "s").equalsIgnoreCase(nodeObject.toString()))) {
                JOptionPane.showMessageDialog(this, "An " + clipboardObject.getObjectTypeName() + " may only be copied into an "
                                                          + clipboardObject.getObjectTypeName() + " folder!");
                return;
            }

            DefaultMutableTreeNode newNode = null;

            if (clipboardObject instanceof Element) {
                newObject = ((Element)clipboardObject).replicate(universe);
                ((Element)newObject).setModType(EPOCObject.getObjectTypeFromName(nodeObject.toString()));
                universe.addElement((Element)newObject);
                newNode = insertAsLastChildOfSelected(newObject);
            } else if (clipboardObject instanceof Action || clipboardObject instanceof Attribute) {
                newObject = ((EPOCObject)clipboardObject).replicate(universe);
                Element ele = getAncestorElement(node);
                ele.addActAtt(newObject);
                newNode = insertAsLastChildOfSelected(newObject);
            }

            // Then select the next (new) object
            if (newNode != null) {
                jTreeUniverse.setSelectionPath(currentTreePath.pathByAddingChild(newNode));
            }
        }
    }

    /**
     * Add a new object to tree.  Class of new object is dependent on tree node selected.
     * @param evt
     */
    public void addObjectActionPerformed(java.awt.event.ActionEvent evt) {
        EPOCObject newObject = null;
        Element pEle = null;
        boolean doRevise = true;

        // retrieve the node that was selected
        DefaultMutableTreeNode node = (DefaultMutableTreeNode)jTreeUniverse.getLastSelectedPathComponent();
        Object obj = node.getUserObject();

        if (EPOC_EDIT_TEMPL && (obj.equals("Actions") || obj instanceof Action 
                || obj.equals("Attributes") || obj instanceof Attribute)
                && getAncestorElement(node).isTemplate()
                &&(JOptionPane.showConfirmDialog(this, "Do you wish to modify parent element template without revision?\n" +
                                                       "Object will be added to this template element everywhere it is used!",
                                "Revise Parent Element", JOptionPane.YES_NO_OPTION) == JOptionPane.YES_OPTION)) {
            doRevise = false;
        }

        if (obj instanceof Universe) {
            // Maybe popup dialog to get module type?
            return;
        }
        if (obj.equals("BIOTA") || obj.equals("ENVIRONMENT") || obj.equals("ACTIVITY")
            || obj.equals("MANAGEMENT") || obj.equals("OUTPUT") || obj.equals("PRESENTATION")) {

            // Create new element
            newObject = universe.createNewElement(EPOCObject.getObjectTypeFromName(obj.toString()));
        } else if (obj.equals("Actions") || obj instanceof Action) {
            if (doRevise) {
                pEle = reviseAncestorElement(node);
            } else {
                pEle = getAncestorElement(node);
            }
            newObject = pEle.createNewActAtt(OBJ_ACT, !doRevise, universe);
            
        } else if (obj.equals("Attributes") || obj instanceof Attribute) {
            if (doRevise) {
                pEle = reviseAncestorElement(node);
            } else {
                pEle = getAncestorElement(node);
            }
            newObject = pEle.createNewActAtt(OBJ_ATT, !doRevise, universe);
            
        } else if (obj.equals("Trial") || obj instanceof Trial) {
            newObject = universe.createNewTrial();
        } else {
            // TODO Dialog to ask what tree object to pick
            return;
        }

        // Now add object into the tree model for updating
        if (newObject != null) {
            // Make sure current node is open
            jTreeUniverse.expandPath(currentTreePath);
          
            DefaultMutableTreeNode newNode = insertAsLastChildOfSelected(newObject);
            // Then select the next (new) object
            if (newObject instanceof Trial) {
                jTreeUniverse.setSelectionPath(currentTreePath.getParentPath().pathByAddingChild(newNode));
            } else {
                jTreeUniverse.setSelectionPath(currentTreePath.pathByAddingChild(newNode));
            }
        }
    }

    /**
     * Remove selected tree object.  Offer to template it first.
     * @param evt
     */
    public void removeObjectActionPerformed(java.awt.event.ActionEvent evt) {
        EPOCObject eo;
        Element pEle = null;
        int objType;
        boolean doRevise = true;

        DefaultMutableTreeNode node = (DefaultMutableTreeNode)jTreeUniverse.getLastSelectedPathComponent();

        try {
            eo = (EPOCObject)node.getUserObject();
            if (eo instanceof Universe) throw new Exception();
        } catch (Exception e) {
            JOptionPane.showMessageDialog(this, "An EPOC object must be selected first!");
            return;
        }

        // Check if a save is needed first
        if (!saveOpposingForm()) return;

        objType = eo.getObjType();

        if (EPOC_EDIT_TEMPL && (eo instanceof Action || eo instanceof Attribute)
                && getAncestorElement(node).isTemplate()
                &&(JOptionPane.showConfirmDialog(this, "Do you wish to modify parent element template without revision?\n" +
                                                       "Object will be removed from this template element everywhere it is used!",
                                "Revise Parent Element", JOptionPane.YES_NO_OPTION) == JOptionPane.YES_OPTION)) {
            doRevise = false;
        }

        // check that template is not a linked object
        if((eo instanceof Element && universe.isLinked(eo))
                || ((eo instanceof Action || eo instanceof Attribute) && getAncestorElement(node).isLinked(eo))) {
            if (JOptionPane.showConfirmDialog(this, "Removing this object will create broken links!\n"
                                                  + "Delete anyway?",
                        "Broken Links", JOptionPane.YES_NO_OPTION) == JOptionPane.NO_OPTION) {
                return;
            }
        }

        // first check if it is not a template and ask if it should be templated first
        if (!eo.isTemplate() 
                && JOptionPane.showOptionDialog(this, "Would you like to template this item before removing it?",
                    "Template?", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null,
                    null, JOptionPane.NO_OPTION) == JOptionPane.YES_OPTION) {
            universe.template(eo);

            // TODO Check if object is linked anywhere
        }

        switch (objType) {
            case OBJ_UNI:
                // Do nothing as yet
                break;
            case OBJ_SPA:
            case OBJ_REP:
                // remove from universe
                universe.removeConfig(eo);

                // replace tree node object with a blank config item
                if (objType == OBJ_SPA) currentTreeNode.setUserObject("Spatial");
                if (objType == OBJ_REP) currentTreeNode.setUserObject("Report");
                // And refresh tree node
                ((DefaultTreeModel)jTreeUniverse.getModel()).nodeChanged(node);
                break;
            case OBJ_TRI:
                // remove from universe
                universe.removeConfig(eo);

                // replace tree node object with a blank config item if it is the last trial
                if (universe.getTrials().size() == 0) {
                    currentTreeNode.setUserObject("Trial");
                    // And refresh tree node
                    ((DefaultTreeModel)jTreeUniverse.getModel()).nodeChanged(node);
                }
                break;
            case OBJ_ELE:
                // remove from arrayList
                universe.removeElement((Element)eo);
                if (EPOC_AUTO_MATCH_LINK_OBJ) universe.repairBrokenLinks();
                break;
            case OBJ_ACT:
                // remove from arrayList
                if (doRevise) {
                    pEle = reviseAncestorElement(node);
                } else {
                    pEle = getAncestorElement(node);
                }
                pEle.removeAction((Action)eo);
                if (EPOC_AUTO_MATCH_LINK_OBJ) pEle.repairBrokenLinks(universe, null);
                break;
            case OBJ_ATT:
                // remove from arrayList
                if (doRevise) {
                    pEle = reviseAncestorElement(node);
                } else {
                    pEle = getAncestorElement(node);
                }
                pEle.removeAttribute((Attribute)eo);
                if (EPOC_AUTO_MATCH_LINK_OBJ) pEle.repairBrokenLinks(universe, null);
        }

        if (!(eo instanceof Spatial || eo instanceof Report)) {
            if ((eo instanceof Trial) && universe.getTrials().size() == 0) {
                // do nothing if you just deleted the last trial
            } else {
                // Then select if exists (in order):
                // next parent child, previous parent child, parent
                int childIdx = currentTreeNode.getParent().getIndex(node);
                if (childIdx < currentTreeNode.getParent().getChildCount() - 1) {
                    jTreeUniverse.setSelectionPath(currentTreePath.getParentPath().pathByAddingChild(currentTreeNode.getParent().getChildAt(childIdx + 1)));
                } else if (childIdx > 0) {
                    jTreeUniverse.setSelectionPath(currentTreePath.getParentPath().pathByAddingChild(currentTreeNode.getParent().getChildAt(childIdx - 1)));
                } else {
                    jTreeUniverse.setSelectionRow(jTreeUniverse.getSelectionRows()[0]-1);
                }
                if (!((eo instanceof Trial) && universe.getTrials().size() == 0)) {
                    ((DefaultTreeModel)jTreeUniverse.getModel()).removeNodeFromParent(node);
                }
            }
        }

        valueChanged(null);
    }

    /**
     * Template the selected object if it is not already so.
     * @param evt
     */
    public void templateTreeObjectActionPerformed(java.awt.event.ActionEvent evt) {
        EPOCObject eo;

        DefaultMutableTreeNode node = (DefaultMutableTreeNode)jTreeUniverse.getLastSelectedPathComponent();

        try {
            eo = (EPOCObject)node.getUserObject();
            if (eo instanceof Universe) throw new Exception();
        } catch (Exception e) {
            JOptionPane.showMessageDialog(this, "An EPOC object must be selected first!");
            return;
        }

        // if its already a template or a save fails
        if (eo.isTemplate() || !saveOpposingForm()) return;
        universe.template(eo);

        // Do repairs on links if required
        if (EPOC_AUTO_MATCH_LINK_OBJ) {
            if (eo instanceof Universe) eo.repairBrokenLinks(universe, null);
            else if (eo instanceof Element) eo.repairBrokenLinks(universe, null);
            else if (eo instanceof Action || eo instanceof Attribute) eo.repairBrokenLinks(universe, getAncestorElement(node));
        }

        ((DefaultTreeModel)jTreeUniverse.getModel()).nodeChanged(node);
        if (eo.getObjType() == OBJ_ELE) {
            // notify children changed for Actions
            DefaultMutableTreeNode attNode = (DefaultMutableTreeNode)node.getChildAt(0);
            int childCnt = ((DefaultTreeModel)jTreeUniverse.getModel()).getChildCount(attNode);
            int[] children = new int[childCnt];
            for (int i = 0 ; i < childCnt; i++) children[i] = i;
            ((DefaultTreeModel)jTreeUniverse.getModel()).nodesChanged(attNode, children);
            // notify children changed for Attributes
            DefaultMutableTreeNode actNode = (DefaultMutableTreeNode)node.getChildAt(1);
            childCnt = ((DefaultTreeModel)jTreeUniverse.getModel()).getChildCount(actNode);
            children = new int[childCnt];
            for (int i = 0 ; i < childCnt; i++) children[i] = i;
            ((DefaultTreeModel)jTreeUniverse.getModel()).nodesChanged(actNode, children);
        }

        valueChanged(null);
    }

    /**
     * Set hourglass cursor and add progStr as progress text.
     * @param progStr
     */
    private void setProgress(final String progStr) {
        jLabelProgress.setText(" " + progStr);
        setCursor(new Cursor(Cursor.WAIT_CURSOR));
    }

    /**
     * Unset hourglass cursor and progress text
     */
    public void endProgress() {
        setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
        jLabelProgress.setText("");
        setEnabled(true);
    }

    /**
     * Read text from file at filePath and display in external R Editor
     * @param filePath
     * @param edTitle
     */
    public void publishInEditor(String filePath, String edTitle) {
        String line = "";

        try {
            File outputFile = new File(filePath);
            FileInputStream fis = new FileInputStream(outputFile);
            DataInputStream dis = new DataInputStream(fis);
            BufferedReader br = new BufferedReader(new InputStreamReader(dis));
            String outfileStr = "";

            while ((line = br.readLine()) != null) {
                outfileStr += line + "\n";
            }
            if (!outfileStr.equals("")) {
                RJEditor rje = new RJEditor();
                rje.setTitle(edTitle);
                rje.getEditor().setText(outfileStr);
                //rje.getEditor().openFile(outputFile.getPath());
            }

            // dispose all the resources after using them.
            fis.close();
            dis.close();
            br.close();
        } catch(Exception e) {
            System.out.println(e.toString());
            e.printStackTrace();
        }
    }

    /**
     * Creates a worker thread to perform validation on universe
     * @return is universe valid
     */
    private boolean validateUniverse() {
        /*
        final ValidationWorker vt = new ValidationWorker(universe);
        vt.addPropertyChangeListener(new java.beans.PropertyChangeListener() {
            public void propertyChange(java.beans.PropertyChangeEvent evt) {
                if (evt.getPropertyName().equals("state") && vt.isDone()) {

                }
            }
        });
        vt.execute();
        */
        
        ValidationThread valThread = new ValidationThread();
        valThread.start();
        try {
            valThread.join();
        } catch (InterruptedException ie) {

        }

        return valThread.isValid();
    }
/*
    class ValidationWorker extends SwingWorker<Boolean, Void> {
        Universe universe;
        boolean passed = true;

        public ValidationWorker(Universe uni) {
            universe = uni;
        }

        protected Boolean doInBackground() throws Exception {
            return universe.validate(true);
        }

        protected void done() {
            try {
                passed = get();
            } catch(Exception e) {
                System.out.println(e.toString());
                e.printStackTrace();
            }
        }
    }
*/
    /**
     * Threaded inner class to perform universe validation
     */
    private class ValidationThread extends Thread {
        boolean passed = true;

        public void run() { passed = universe.validate(true); }

        public boolean isValid() { return passed; }
    }

    /**
     * Sub-class the DefaultTreeSelectionModel to allow cancellation of new
     * selection paths if current object can't be saved
     */
    private class VetoableTreeSelectionModel extends DefaultTreeSelectionModel {
        public void setSelectionPath(TreePath path){
            // Save current form object if required before selecting new
            if (currentTreePath != null && !saveOpposingForm()) return;

            super.setSelectionPath(path);
        }
    }

    /**
     * Sub class mouse adaptor for tree object right-clicks
     */
    private class PopupListener extends MouseAdapter {
        private JPopupMenu popup = new JPopupMenu();

        private JMenuItem upMenuItem;
        private JMenuItem addMenuItem;
        private JMenuItem remMenuItem;
        private JMenuItem copyMenuItem;
        private JMenuItem pasteMenuItem;
        private JMenuItem tmpMenuItem;

        PopupListener(JPopupMenu ppp) {
            popup = ppp;
            
            // Add a popup menu to tree objects
            upMenuItem = new JMenuItem("Move Up");
            upMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_UP, InputEvent.ALT_DOWN_MASK));
            upMenuItem.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    upObjectActionPerformed(evt);
                }
            });

            addMenuItem = new JMenuItem("Add New");
            addMenuItem.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    addObjectActionPerformed(evt);
                }
            });

            remMenuItem = new JMenuItem("Remove");
            remMenuItem.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    removeObjectActionPerformed(evt);
                }
            });

            copyMenuItem = new JMenuItem("Copy");
            copyMenuItem.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    copyObjectActionPerformed(evt);
                }
            });

            pasteMenuItem = new JMenuItem("Paste");
            pasteMenuItem.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    pasteObjectActionPerformed(evt);
                }
            });

            tmpMenuItem = new JMenuItem("Template");
            tmpMenuItem.addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent evt) {
                    templateTreeObjectActionPerformed(evt);
                }
            });
        }

        @Override
        public void mousePressed(MouseEvent e) {
            maybeShowPopup(e);
        }

        @Override
        public void mouseReleased(MouseEvent e) {
            maybeShowPopup(e);
        }

        private void maybeShowPopup(MouseEvent e) {
            if (e.isPopupTrigger()) {
                // Select right-clicked tree node first
                jTreeUniverse.setSelectionPath(jTreeUniverse.getPathForLocation(e.getX(), e.getY()));

                modifyPopup();
                popup.show(e.getComponent(), e.getX(), e.getY());
            }
        }

        /**
         * Modify which menuitems are shown in the pop-up
         * ATM hide the copy/paste option as there is a problem with att/act of a
         * copied element not being revised with incremental revision numbers.
         */
        private void modifyPopup() {
            DefaultMutableTreeNode node = (DefaultMutableTreeNode)
                       jTreeUniverse.getLastSelectedPathComponent();

            /* if nothing is selected */
            if (node == null) return;

            // clear popup
            popup = new JPopupMenu();
            // retrieve the node object that was selected
            Object nodeObject = node.getUserObject();
            if ((nodeObject instanceof Universe) || nodeObject.equals("Configuration")
                    || nodeObject.equals("Spatial") || nodeObject.equals("Report")
                    || nodeObject.equals("Trial")) {
                //popup = nullPopup;

            } else if (nodeObject.equals("BIOTA") || nodeObject.equals("ENVIRONMENT")
                    || nodeObject.equals("ACTIVITY") || nodeObject.equals("MANAGEMENT")
                    || nodeObject.equals("OUTPUT") || nodeObject.equals("PRESENTATION")) {
                popup.add(addMenuItem);
                if (clipboardObject != null && clipboardObject instanceof Element) {
                    //popup.add(pasteMenuItem);
                }
            } else if (nodeObject.equals("Actions") || nodeObject.equals("Attributes")) {
                popup.add(addMenuItem);
                if (clipboardObject != null && (clipboardObject.getObjectTypeName() + "s").equalsIgnoreCase(nodeObject.toString())) {
                    //popup.add(pasteMenuItem);
                }
            } else if (nodeObject instanceof Spatial || nodeObject instanceof Report) {

            } else if (nodeObject instanceof Trial) {
                popup.add(upMenuItem);
                popup.add(addMenuItem);
            } else if (nodeObject instanceof Element || nodeObject instanceof Action
                    || nodeObject instanceof Attribute) {
                popup.add(upMenuItem);
                
            } else {
                popup.add(addMenuItem);
            }
            if (nodeObject instanceof EPOCObject && !(nodeObject instanceof Universe)) {
                popup.add(remMenuItem);
                //popup.add(copyMenuItem);
                if (!((EPOCObject)nodeObject).isTemplate()) popup.add(tmpMenuItem);
            }
        }
    }
    /**
    * @param args the command line arguments
    */
    public static void main(String args[]) {
        try {
            UIManager.setLookAndFeel("com.sun.java.swing.plaf.windows.WindowsLookAndFeel");
        } catch (Exception ex) {
            ex.printStackTrace();
        }
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                final SplashScreen splash = SplashScreen.getSplashScreen();
                if (splash != null) {
                    Graphics2D g = (Graphics2D)splash.createGraphics();
                    if (g != null) {
                        g.setComposite(AlphaComposite.Clear);
                        g.setPaintMode();
                        g.setColor(Color.BLACK);
                        g.setFont(new Font(Font.SANS_SERIF, Font.BOLD, 50));
                        g.drawString("EPOC Builder\u00A9", splash.getSize().width/2 - 180, splash.getSize().height/2);
                        g.setFont(new Font(Font.SANS_SERIF, Font.BOLD, 35));
                        g.drawString(EPOC_VER, splash.getSize().width/2 - 40, splash.getSize().height/2 + 30);
                        g.setFont(new Font(Font.SANS_SERIF, Font.BOLD, 20));
                        g.drawString("Loading...", splash.getSize().width/2 - 40, splash.getSize().height/2 + 80);
                        splash.update();
                    }
                }

                EPOCBuilderUI ebUI = new EPOCBuilderUI();
                ebUI.setLocationRelativeTo(null);
                ebUI.setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel jLabelProgress;
    private javax.swing.JMenuBar jMenuBar;
    private javax.swing.JMenu jMenuDB;
    private javax.swing.JMenu jMenuFile;
    private javax.swing.JMenu jMenuGenerate;
    private javax.swing.JMenu jMenuHelp;
    private javax.swing.JMenuItem jMenuItemAbout;
    private javax.swing.JMenuItem jMenuItemDeleteDB;
    private javax.swing.JMenuItem jMenuItemDeleteUni;
    private javax.swing.JMenuItem jMenuItemExit;
    private javax.swing.JMenuItem jMenuItemExportDB;
    private javax.swing.JMenuItem jMenuItemGenerateCalendar;
    private javax.swing.JMenuItem jMenuItemGenerateR;
    private javax.swing.JMenuItem jMenuItemImportDB;
    private javax.swing.JMenuItem jMenuItemImportXML;
    private javax.swing.JMenuItem jMenuItemNewDB;
    private javax.swing.JMenuItem jMenuItemNewUni;
    private javax.swing.JMenuItem jMenuItemOpenDB;
    private javax.swing.JMenuItem jMenuItemOpenUni;
    private javax.swing.JMenuItem jMenuItemOptions;
    private javax.swing.JMenuItem jMenuItemOrphans;
    private javax.swing.JMenuItem jMenuItemRationalise;
    private javax.swing.JMenuItem jMenuItemRefresh;
    private javax.swing.JMenuItem jMenuItemRepair;
    private javax.swing.JMenuItem jMenuItemRun;
    private javax.swing.JMenuItem jMenuItemSaveAsUni;
    private javax.swing.JMenuItem jMenuItemSaveUni;
    private javax.swing.JMenuItem jMenuItemTextEditor;
    private javax.swing.JMenuItem jMenuItemTimeline;
    private javax.swing.JMenuItem jMenuItemValidate;
    private javax.swing.JMenu jMenuTools;
    private javax.swing.JMenu jMenuView;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JSeparator jSeparator1;
    private javax.swing.JSeparator jSeparatorDB;
    private javax.swing.JSeparator jSeparatorExit;
    private javax.swing.JSplitPane jSplitPane1;
    private javax.swing.JTree jTreeUniverse;
    // End of variables declaration//GEN-END:variables

}
